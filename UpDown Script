

-- UpDown Script (Полная переработка)
-- Помести как LocalScript внутрь перетаскиваемого GUI (например Frame)
-- Поддерживает: мышь, тач, AnchorPoint, ограничения по границам родителя
-- Параметры:
--   LOCK_X = true  -> фиксировать X (движение только по Y)
--   LOCK_Y = true  -> фиксировать Y (движение только по X)
-- Если оба false — свободное перемещение по обеим осям.

local gui = script.Parent
local UserInputService = game:GetService("UserInputService")

-- Настройки (изменяй при необходимости)

local LOCK_X = false
local LOCK_Y = false
local ROUNDOFF = true -- округлять пиксели при установке Position

-- Внутренние состояния

local dragging = false
local dragInput = nil
local dragStartScreenPos = Vector2.new(0, 0) -- позиция курсора/тача при начале (экран)
local startAbsGuiPos = Vector2.new(0, 0)     -- AbsolutePosition GUI при начале (экран)

-- Вспомогательные функции

-- Получить границы допустимой "AbsolutePosition" левого-верхнего угла GUI (в координатах экрана)

local function getAbsBounds()
    local parent = gui.Parent
    if not parent then
        return 0, 0, 0, 0
    end
    local pPos = parent.AbsolutePosition
    local pSize = parent.AbsoluteSize
    local gSize = gui.AbsoluteSize

    local minX = pPos.X
    local maxX = pPos.X + math.max(0, pSize.X - gSize.X)
    local minY = pPos.Y
    local maxY = pPos.Y + math.max(0, pSize.Y - gSize.Y)

    return minX, maxX, minY, maxY
end

-- Перевод абсолютной позиции (экран) в локальную позицию относительно родителя (в пикселях)

local function absToLocal(absPos)
    local parent = gui.Parent
    local pPos = parent.AbsolutePosition
    return Vector2.new(absPos.X - pPos.X, absPos.Y - pPos.Y)
end

-- Установить gui.Position корректно, учитывая AnchorPoint и желаемый абсолютный левый-верх (absPos)

local function setGuiPositionByAbsoluteTopLeft(absPos)
    local parent = gui.Parent
    if not parent then return end
    local localPos = absToLocal(absPos) -- позиция левого-верх относительно родителя (в пикселях)
    local anchor = gui.AnchorPoint
    local gSize = gui.AbsoluteSize
    local offsetX = localPos.X + anchor.X * gSize.X
    local offsetY = localPos.Y + anchor.Y * gSize.Y
    if ROUNDOFF then
        offsetX = math.floor(offsetX + 0.5)
        offsetY = math.floor(offsetY + 0.5)
    end
    gui.Position = UDim2.new(0, offsetX, 0, offsetY)
end

-- Ограничить абсолю��ную позицию по границам родителя

local function clampAbsPos(absPos)
    local minX, maxX, minY, maxY = getAbsBounds()
    return Vector2.new(
        math.clamp(absPos.X, minX, maxX),
        math.clamp(absPos.Y, minY, maxY)
    )
end

-- Обработка начала ввода на GUI

gui.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragInput = input
        dragStartScreenPos = Vector2.new(input.Position.X, input.Position.Y)
        startAbsGuiPos = Vector2.new(gui.AbsolutePosition.X, gui.AbsolutePosition.Y)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- захватываем фокус чтобы InputChanged продолжал приходить
            pcall(function() input:CaptureFocus() end)
        end
    end
end)

-- Обработка завершения ввода

gui.InputEnded:Connect(function(input)
    if dragging and dragInput and input == dragInput then
        dragging = false
        dragInput = nil
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            pcall(function() input:ReleaseFocus() end)
        end
    end
end)

-- Единая обработка изменения ввода (мышь/тач)

local function handleInputChanged(input)
    if not dragging then return end
    if input.UserInputType ~= Enum.UserInputType.MouseMovement and input.UserInputType ~= Enum.UserInputType.Touch then
        return
    end

    local currentPos = Vector2.new(input.Position.X, input.Position.Y)
    local delta = currentPos - dragStartScreenPos
    local newAbs = startAbsGuiPos + delta

    -- Если заблокирована ось, фиксируем координату от startAbsGuiPos
    if LOCK_X then
        newAbs = Vector2.new(startAbsGuiPos.X, newAbs.Y)
    end
    if LOCK_Y then
        newAbs = Vector2.new(newAbs.X, startAbsGuiPos.Y)
    end

    -- Ограничиваем по границам родителя
    newAbs = clampAbsPos(newAbs)

    setGuiPositionByAbsoluteTopLeft(newAbs)
end

-- Подключаем оба источника InputChanged: GUI и UserInputService

gui.InputChanged:Connect(handleInputChanged)
UserInputService.InputChanged:Connect(function(input)
    -- важно реагировать только если это тот же input, который мы захватили
    if dragging and dragInput and input == dragInput then
        handleInputChanged(input)
    end
end)

-- Если размеры/позиции родителя или самого GUI изменились, корректируем позицию чтобы остаться в пределах

local function clampPositionToParent()
    local minX, maxX, minY, maxY = getAbsBounds()
    local absPos = gui.AbsolutePosition
    local clamped = Vector2.new(
        math.clamp(absPos.X, minX, maxX),
        math.clamp(absPos.Y, minY, maxY)
    )
    if clamped ~= absPos then
        setGuiPositionByAbsoluteTopLeft(clamped)
    end
end

if gui.Parent then
    gui.Parent:GetPropertyChangedSignal("AbsoluteSize"):Connect(clampPositionToParent)
    gui.Parent:GetPropertyChangedSignal("AbsolutePosition"):Connect(clampPositionToParent)
end
gui:GetPropertyChangedSignal("AbsoluteSize"):Connect(clampPositionToParent)
gui:GetPropertyChangedSignal("AnchorPoint"):Connect(clampPositionToParent)
gui:GetPropertyChangedSignal("AbsolutePosition"):Connect(clampPositionToParent)

-- Доп: если хочешь движение только по Y — включи LOCK_X = true выше или вызови этот скрипт с настройкой.
-- Конец скрипта
